.. _playbooks:

*********
Playbooks
*********

Playbooks serve two purposes in fsstratify: they are a special kind of usage model, which lets you define which
operations to carry out manually; and they are used to log the operations carried out by all of the other usage models.

The following sections provide a list of available playbooks commands and their parameters.

Overview
========
A playbook is a simple text file with one command per line. A command corresponds to an :ref:`operation <operations>`
and its parameters.

When the playbook is used as input for a simulation, it is first completely parsed to check for syntax errors.
After that the simulation will execute the commands listed in the playbook line by line. Note that there are still
errors which can occur during the simulation, which are not check during the initial parsing. Such errors include
things like trying to move a non-existing file or filling the file system beyond capacity.

All simulations---also the ones that use a playbook as input---write a new playbook file named ``simulation.playbook``,
which is a log of all operations carried out during the simulation. This can be used to review which operations have
been generated by a usage model, but also to re-run a simulation or parts of a simulation possibly with some manual
adjustments. Note that an input playbook and the playbook created during the corresponding simulation will very likely
be not identical as the logged playbook contains normalized paths all optional parameters with their default values.
The behavior of both playbooks is identical, though.

A simple playbook looks like this:

.. code-block::

   write /tqqcnaqi size=566231040 chunk_size=512
   extend /tqqcnaqi extend_size=552599552 chunk_size=512
   mkdir /lsgfwdol
   cp /tqqcnaqi /lsgfwdol/
   rm /tqqcnaqi
   write /pomrsafw size=958464
   extend /lsgfwdol/tqqcnaqi extend_size=10485760 chunk_size=512

This playbook creates a new file ``tqqcnaqi`` of size 540 MiB in chunks of 512 bytes. After that the file is extended by
527 MB, again in chunks of 512 bytes. Then, a directory ``lsgfwdol`` is created and the file ``tqqcnaqi`` is copied
into this directory. Finally, another file ``pomrsafw`` is created and the first file is extended again.

As you can see, a playbook read pretty much like some kind of shell or batch script. Most of the valid playbook
commands were designed to mimic simpler versions of well known Unix commands. Note, however, that besides the name and
the conceptual behavior, playbook commands and their "real" counterparts do not have anything in common. Especially,
fsstratify does not call the actual commands, but only implements what you would expect from the command.
For implementation details, please refer to the :ref:`operations documentation <operations>`.


Playbook Commands
=================
Here is the list of currently supported playbook commands listed in alphabetical order.

cp
--
Copies a file from the simulation file system to a new path inside the simulation file system.

Directories and their contents are copied just as files, i.e. there is no recursive flag or anything like that.

The source file has to exist, otherwise a ``SimulationError`` is raised.

Parameters:

:src: the source file to copy relative to the simulation mount point (``Path``, `mandatory`)
:dst: the destination path relative to the simulation mount point (``Path``, `mandatory`)

Examples:

.. code-block:: shell

   # copy a single file
   cp some-dir/src-file dst-file

   # copy a directory
   cp some-dir new-dir

If a single file is copied, then no metadata is preserved; if a directory structure is copied, the metadata of the
files in the directory is preserved to some extent (see the TODO for more information).


extend
------
Extends an existing file with a given number of random bytes.

The file to extend must exists and the number of bytes to append must be > 0.

Parameters:

:path: ``Path`` the path of the file to extend (`mandatory`)
:extend_size: ``int`` the number of random bytes to append to the file (`mandatory`)
:chunked: ``bool`` if set to ``True`` the data is written in chunks of ``chunk_size`` bytes (`optional`, default: ``False``)
:chunk_size: ``int`` number of bytes to write in one chunk if ``chunked`` is set to ``True`` (`optional`, default: 512)

Note that ``chunk_size`` is only used, when ``chunked`` is set to a ``True`` value. Specifying ``chunk_size`` alone
has no effects.

Even if ``chunked`` is set to a ``False`` value, larger values for ``extend_size`` will cause chunked writing.
The maximal size to write in one chunk is currently :math:`2^{28}-1` bytes (roughly 256 MiB).

Examples:

.. code-block:: shell

   # append 1024 bytes to /some/file all in one chunk
   extend /some/file extend_size=1024

   # append 1024 bytes to /some/file in two chunks of 512 bytes (512 is the default chunk size)
   extend /some/file extend_size=1024 chunked=yes

   # append 4096 bytes to /some/file in two chunks of 1024 bytes
   extend /some/file extend_size=4KiB chunked=yes chunk_size=1024

   # this will still write the 16 KiB in one single chunk as chunked is not set to True
   extend /some/file extend_size=16KiB chunk_size=1024

   # this will write in chunks of 2**28-1 as the max. single chunk size is exceeded
   extend /some/file extend_size=3GiB


mkdir
-----
Creates a new directory.

Note that the directory to create must not exist already and that missing parent directories are not created
automatically. You can change this behavior using the parameters ``parents`` and ``exist_ok`` as described below.

Parameters:

:path: ``Path`` the path of the directory to create relative to the simulation mount point (`mandatory`)
:parents: ``bool`` create non-existing parent directories when necessary (`optional`, default: ``False``)
:exist_ok: ``bool`` when set to ``False`` an error is raised when the directory already exists (`optional`, default: ``False``)

Examples:

.. code-block:: shell

   # create the new directory /some-directory
   mkdir /some-directory

   # create a new directory and its parents
   mkdir /first-dir/second-dir parent=true

   # create it again
   mkdir /first-dir/second-dir exist_ok=true


mv
--
Moves a file from the simulation file system to a new path inside the simulation file system.

:src: the source file to move relative to the simulation mount point
:dst: the destination path relative to the simulation mount point

Example:

.. code-block::

   mv some-dir/src-file dst-file


rm
--
Removes the given file.

:path: the path of the file to remove

Example:

.. code-block::

   rm some-file


write
-----
Creates a new file with a given number of random bytes or overwrites an existing file.

The file number of bytes to write must be > 0.

Parameters:

:path: ``Path`` the path of the file to write (`mandatory`)
:size: ``int`` the number of random bytes to write (`mandatory`)
:chunked: ``bool`` if set to ``True`` the data is written in chunks of ``chunk_size`` bytes (`optional`, default: ``False``)
:chunk_size: ``int`` number of bytes to write in one chunk if ``chunked`` is set to ``True`` (`optional`, default: 512)

Note that ``chunk_size`` is only used, when ``chunked`` is set to a ``True`` value. Specifying ``chunk_size`` alone
has no effects.

Even if ``chunked`` is set to ``False``, larger values for ``size`` will cause chunked writing.
The maximal size to write in one chunk is currently :math:`2^{28}-1` bytes (roughly 256 MiB).

Examples:

.. code-block:: shell

   # write 1024 bytes to /some/file all in one chunk
   write /some/file size=1024

   # write 1024 bytes to /some/file in two chunks of 512 bytes (512 is the default chunk size)
   write /some/file size=1024 chunked=yes

   # write 4096 bytes to /some/file in two chunks of 1024 bytes
   write /some/file size=4KiB chunked=yes chunk_size=1024

   # this will still write the 16 KiB in one single chunk as chunked is not set to True
   write /some/file size=16KiB chunk_size=1024

   # this will write in chunks of 2**28-1 as the max. single chunk size is exceeded
   write /some/file size=3GiB
