import json
import logging
import random
import shutil
import subprocess
import sys
import typing
from contextlib import ExitStack
from dataclasses import dataclass
from datetime import datetime as dt, timezone
from logging import Logger
from pathlib import Path

import numpy as np
from jinja2 import Template
from tqdm import tqdm

from fsstratify.configuration import Configuration, SIMULATION_CONFIG_FILE_NAME
from fsstratify.errors import ConfigurationError, SimulationError
from fsstratify.execenv import (
    get_execution_environment,
    ExecutionEnvironment,
    WindowsEnvironment,
)
from fsstratify.filesystems import SimulationVirtualFileSystem
from fsstratify.operations import Remove, Operation, Time
from fsstratify.prepopulation import prepopulate_with, get_prepopulation_dataset_path
from fsstratify.usagemodels import get_model_registry, UsageModelConfiguration
from fsstratify.usagemodels.base import UsageModel
from fsstratify.utils import (
    get_logger,
    is_user_admin,
    merge_overlapping_fragments,
)


class Simulation:
    def __init__(self, directory: Path, config: Configuration, usage_model: UsageModel):
        self._config: Configuration = config
        self._logger: Logger = get_logger(
            name="Simulation",
            loglevel=self._config["log_level"],
            logfile=self._config["simulation_log"],
        )
        self._directory: Path = directory.resolve().absolute()
        self._usage_model = usage_model
        self._operations = []
        self._output_playbook = None
        self._context_stack: ExitStack = ExitStack()
        self._strata_log = self._context_stack.enter_context(
            open(self._config["strata_log"], "w", encoding="utf-8")
        )
        self._open_output_playbook()
        self._vfs: typing.Optional[SimulationVirtualFileSystem] = None
        self._simulation_step: int = 1

    def run(self) -> None:
        """This method starts the simulation.

        It creates an execution environment, initializes the usage model, iterates over
        the operations generated by the usage model, and executes the operations."""
        self._ensure_runs_as_privileged_user()
        self._logger.info("Creating execution environment")
        try:
            with get_execution_environment(self._config) as exec_env:
                self._initialize_simulation(exec_env)
                if "prepopulate_with" in self._config["file_system"]:
                    self._prepopulate_file_system()
                    exec_env.flush_simulation_vfs()
                    if not self._config["file_system"]["prepopulate_with"]["mutable"]:
                        self._vfs.collect_immutable_files()
                self._logger.info(
                    'Starting simulation in directory "%s"', self._directory
                )
                for operation in tqdm(
                    self._operations,
                    desc="Simulation step",
                    total=self._operations.steps(),
                ):
                    exec_env.execute(operation)
                    stratum = self._get_stratum(operation)
                    self._write_stratum_line(stratum)
                    self._write_playbook_line(operation.as_playbook_line())
                    self._simulation_step += 1
                self._logger.info(
                    'Finished simulation in directory "%s"', self._directory
                )
        except Exception as e:
            # TODO: write error to log
            self._logger.error(
                "An error occurred during the fsstratify simulation.", exc_info=True
            )
            raise

    def _ensure_runs_as_privileged_user(self) -> None:
        self._logger.info("Checking user rights")
        try:
            is_priv_user = is_user_admin()
        except NotImplementedError:
            msg = "Unable to determine user privileges. fsstratify simulations have to run with elevated permissions."
            self._logger.info(msg)
            raise SimulationError(msg)

        if not is_priv_user:
            raise SimulationError(
                "No privileged user status detected. fsstratify simulations have to run with elevated permissions."
            )

    def _initialize_simulation(self, exec_env: ExecutionEnvironment) -> None:
        self._vfs = exec_env.get_simulation_vfs()
        self._initialize_usage_model()
        random.seed(self._config["seed"])

    def _initialize_usage_model(self):
        self._usage_model.set_simulation_parameters(self._vfs)
        self._operations = self._usage_model

    def _prepopulate_file_system(self):
        dataset = get_prepopulation_dataset_path(
            self._config["file_system"]["prepopulate_with"]["dataset"],
            self._config["path"],
        )
        prepopulate_with(self._config["mount_point"], dataset)

    def _open_output_playbook(self) -> None:
        if self._config["write_playbook"]:
            self._output_playbook = self._context_stack.enter_context(
                open(self._config["output_playbook_path"], "w", encoding="utf-8")
            )
            header = (
                "### Autogenerated playbook based on simulation run at"
                f' {dt.now().strftime("%FT%T")} ###\n#\n'
            )
            self._output_playbook.write(header)

    def _write_playbook_line(self, line: str) -> None:
        if self._config["write_playbook"]:
            self._output_playbook.write(f"{line}\n")

    def _get_stratum(self, operation: Operation):
        stratum = operation.as_dict()
        if self._config["write_timestamps"] and isinstance(operation, Remove):
            stratum["timestamp"] = dt.now(timezone.utc).isoformat()
        if not isinstance(operation, Remove) and not isinstance(operation, Time):
            stratum["affected_files"] = []
            files = self._vfs.get_files_below(operation.target)
            for file in files:
                stratum["affected_files"].append(
                    {
                        "path": str(file),
                        "allocated_areas": self._vfs.get_allocated_fragments_for_file(
                            file
                        ),
                    }
                )

                if self._config["write_timestamps"]:
                    stratum["timestamps"] = self._vfs.get_timestamps_for_file(file)

        stratum["fs_areas"] = merge_overlapping_fragments(
            self._vfs.get_file_system_areas()
        )
        return stratum

    def _write_stratum_line(self, stratum_data: dict) -> None:
        stratum_line = json.dumps(stratum_data, cls=_StratumJsonEncoder)
        self._strata_log.write(f"{stratum_line}\n")


def initialize_directory(directory: Path, replicate=None, model=None) -> int:
    # TODO: refactor this
    directory = Path(directory)
    try:
        directory.mkdir()
    except FileExistsError as err:
        print(
            f'[!] Error: File or directory already exists: "{directory}"',
            file=sys.stderr,
        )
        return err.errno
    except PermissionError as err:
        print(f'[!] Error: Permission denied: "{directory}"', file=sys.stderr)
        return err.errno

    config = _generate_config(replicate=replicate, model=model)

    with (directory / SIMULATION_CONFIG_FILE_NAME).open("w") as config_file:
        config_file.write(config)
    (directory / "prepopulation_datasets").mkdir()
    return 0


def _generate_config(replicate: str = None, model: str = None) -> str:
    if replicate:
        return _generate_replication_config(replicate)
    elif model:
        return _generate_config_with_usage_model(model)
    else:
        return _generate_default_config()


def _generate_default_config() -> str:
    template = Template(_CONFIG_TEMPLATE)
    return template.render(
        {
            "seed": random.randrange(sys.maxsize),
            "usage_model": _DEFAULT_CONFIG_USAGE_MODEL,
        },
        trim_blocks=True,
    )


def _generate_replication_config(replication: str) -> str:
    replication_templates_dir = Path(__file__).parent / "replications"
    replication_template_file = replication_templates_dir / (replication + ".yml.j2")
    if not replication_template_file.is_file():
        raise ConfigurationError(f"Replication template for '{replication}' not found.")
    with replication_template_file.open() as fd:
        template = Template(fd.read())
    return template.render({"seed": random.randrange(sys.maxsize)}, trim_blocks=True)


def _generate_config_with_usage_model(model: str) -> str:
    try:
        model_parameters = get_model_registry()[model].get_yaml_template()
    except KeyError:
        raise ConfigurationError(f'Invalid usage model "{model}".')
    model_config = Template(_USAGE_MODEL_TEMPLATE).render(
        {"model_name": model, "parameters": model_parameters},
        trim_blocks=True,
    )
    template = Template(_CONFIG_TEMPLATE)
    return template.render(
        {"seed": random.randrange(sys.maxsize), "usage_model": model_config},
        trim_blocks=True,
    )


def clean_sim_dir_win(sim_dir: Path, keep=None):
    if keep is None:
        keep = {"simulation.yml"}
    regular_files = {
        sim_dir / "simulation.yml",
        sim_dir / "simulation.strata",
        sim_dir / Path("simulation.playbook"),
        sim_dir / Path("simulation.log"),
    }
    vhd = sim_dir / "fs.vhd"
    mnt = sim_dir / "mnt"
    for f in regular_files:
        if f.name in keep:
            continue
        if f.exists():
            f.unlink()
    if vhd.exists():
        sub = subprocess.run(
            (
                "powershell",
                "-Command",
                f'Write-Output (Get-DiskImage -ImagePath "{vhd.resolve()}").attached',
            ),
            check=False,
            capture_output=True,
            encoding="utf8",
        )
        attached = False
        if sub.returncode == 0 and sub.stdout.strip() == "True":
            attached = True
        if attached:
            if mnt.exists():
                sub = subprocess.run(
                    (
                        "powershell",
                        "-Command",
                        f'Write-Output (Get-Volume -FilePath "{mnt}" | Get-DiskImage).ImagePath',
                    ),
                    check=False,
                    capture_output=True,
                    encoding="utf8",
                )
                mounted = False
                if (
                    sub.returncode == 0
                    and Path(sub.stdout[:-1]).resolve() == vhd.resolve()
                ):
                    mounted = True
                if mounted:
                    WindowsEnvironment.unmount(mnt)
            WindowsEnvironment.detach_vdisk(vhd)
        vhd.unlink()
    if mnt.exists():
        if mnt.is_symlink() or mnt.is_file():  # happens in certain cases
            mnt.unlink()
        else:
            shutil.rmtree(mnt)


def clean_sim_dir_linux(sim_dir: Path, keep=None):
    if keep is None:
        keep = {"simulation.yml"}
    regular_files = {
        sim_dir / "simulation.yml",
        sim_dir / "simulation.strata",
        sim_dir / Path("simulation.playbook"),
        sim_dir / Path("simulation.log"),
    }
    img = sim_dir / "fs.img"
    img = img.resolve()
    mnt = sim_dir / "mnt"
    mnt = mnt.resolve()
    for f in regular_files:
        if f.name in keep:
            continue
        if f.exists():
            f.unlink()
    if mnt.exists():
        if mnt.is_mount():
            subprocess.run(
                [
                    "umount",
                    "--force",
                    "--detach-loop",
                    str(mnt),
                ],
                check=True,
            )
        shutil.rmtree(mnt)
    if img.exists():
        img.unlink()


class _StratumJsonEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Path):
            return str(o)
        if isinstance(o, np.integer):
            return int(o)
        return super().default(o)


_CONFIG_TEMPLATE: str = """---
seed: {{ seed }}
write_playbook: no
write_timestamps: no
data_generator:

file_system:
  type: FILE_SYSTEM_TYPE
  formatting_parameters: "FS_FORMATTING_PARAMETERS"
  # prepopulate_with:
  #   dataset: PREPOPULATION_DATASET

volume:
  type: file
  keep: no
  size: IMAGE_SIZE

{{ usage_model }}
"""

# seed = random.randrange(sys.maxsize)
_DEFAULT_CONFIG_USAGE_MODEL = """
usage_model:
  type: USAGE_MODEL
  parameters:
    # usage model parameters below, e.g.:
    # first_parameter: abc
    # second_parameter: 123
"""

_USAGE_MODEL_TEMPLATE = """
usage_model:
  type: {{ model_name }}
  parameters:
  {%- for parameter in parameters %}
    # {{ parameter.key }}: {{ parameter.value -}}
  {% endfor %}
"""
